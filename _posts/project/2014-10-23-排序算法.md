######2014-10-23-排序算法.md


---
**冒泡排序**

思想：冒泡法

描述：两两比较，只要两数顺序错误就互换，一次遍历之后，最后一个元素一定是最大的。较大元素一个一个像冒泡一样转移到数组后方

---
**选择排序**

思想：每次找到最小的值，放在最前的位置

描述：第一小的数和a[0]互换,第二小的数和a[1]互换……

---
**插入排序**

思想：扑克牌插入

描述：假设前面的所有位已经排好序，当前位到后面的都没排序。从当前数往前面遍历，先保存当前数值，找到前一位，如果比当前数大，就往后面挪一位，如果比当前位小，就存在该位的后面

---
**希尔排序**

思想：分成很多组，每一组都插入排序

描述：将数组按步长分成较小长度的数组，使得相同步长距离的数在一个小数组，我们对这个小组进行排序。然后改步长，每改一次都排序一次，使得每次排序之后的小数字都排到前面去，大数字都排到后面去了。随着步长的变小，小数组规模也慢慢变大，但是小数组基本排好序，所以用插入排序不需要太多时间。最后一次排序就是原数组进行一次步长为1的排序，也就是直接插入排序了。

---
**堆排序**

思想：有一个堆（其实就是完全二叉树）

描述：

---
**合并排序**

思想：分治法（把问题分解成很多小问题，直到小问题很好解决）

描述：把要排序的数组a[]分成两半a1[],a2[]，然后对a1[],a2[]分别再分。直到分成只有一个元素，再把分开的元素合并。合并的时候，才是真正的排序。两堆数组排序a1[],a2[]，已经是按照大小顺序排好了，现在就剩下合并了。那就从两个数组的各自第一个元素开始比较，如果a[i]<a[j]，就把a[i]存回去，i++。为了防止数组溢出，需要设置一个哨兵，那就是最后一个元素了，大于一切0到1的数字，对应的i就不会自加了。

---
**快速排序**

思想：找一个标杆，比标杆小的数放在标杆前面，比标杆大的数放在标杆后面，递归

描述：对整个数组找一个标杆，我们选择最后一个数，存在临时变量，然后分别从最前面一个值和最后一个值开始往中间遍历，首先，比标杆大的先填在标杆处，比标杆小的那个数就保存在前一个比标杆大已经移动的位置，（因为这个值已经保存了，相当于空出来了），同意，再比标杆大的就存在前一个比标杆小的已经移动的位置上面。这样每次都有一个空来填需要移动的数。最后将标杆保存在中间留出的空位上。并返回该处的位置。该位置前面的数虽然都比标杆小，但仍未排序，就可以调用快排，递归实现了。